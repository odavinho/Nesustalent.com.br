/**
 * @file Firestore Security Rules for NexusTalent Platform
 * @core_philosophy This ruleset enforces a strict user-ownership model for personal data,
 *  and role-based access control for shared resources. It leverages denormalization
 *  to avoid costly `get()` calls and ensures relational integrity where critical.
 * @data_structure The data is organized hierarchically:
 *  - /users/{userId}: User profiles, accessible only to the user and admins.
 *  - /courses/{courseId}: Course information, publicly readable.
 *  - /courses/{courseId}/modules/{moduleId}: Course modules, publicly readable.
 *  - /enrollments/{enrollmentId}: User enrollments, accessible only to the user and admins.
 *  - /jobPostings/{jobPostingId}: Job postings, publicly readable, but only recruiters can create/modify.
 *  - /applications/{applicationId}: Job applications, accessible to the applicant and recruiter.
 * @key_security_decisions
 *  - Listing all users is disallowed to protect privacy.
 *  - Data validation is limited to authorization-critical fields for prototyping.
 *  - Public read access is granted to some collections to support open discovery.
 * @denormalization The `applications` collection uses a composite key `userId_jobPostingId`
 *  for the document ID. This ensures uniqueness and enables efficient security rules
 *  based on ownership.
 * @structural_segregation Publicly readable data (courses, job postings) is stored in
 *  top-level collections, separate from private user data.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to user profile data.
     * @path /users/{userId}
     * @allow (get, update, delete) User with matching userId. (e.g., request.auth.uid == userId)
     * @allow (create) User creating their own profile (e.g., request.auth.uid == userId)
     * @deny (get, update, delete) Any other user.
     * @deny (create) Any other user attempting to create a profile with a different userId.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      function isSignedIn() {
        return request.auth != null;
      }
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isOwner(userId);
      allow delete: if isSignedIn() && isOwner(userId);
    }

    /**
     * @description Controls access to course information.
     * @path /courses/{courseId}
     * @allow (get, list) Public read access to course information.
     * @allow (create) Only authenticated users can create courses, ensuring trainerId matches.
     * @allow (update, delete) Only the trainer (trainerId) can update or delete the course.
     * @deny Write without authentication.
     * @principle Public read access with owner-only writes.
     */
    match /courses/{courseId} {
      function isSignedIn() {
        return request.auth != null;
      }

      allow get, list: if true;

      allow create: if isSignedIn() && request.resource.data.trainerId == request.auth.uid;
      allow update: if isSignedIn() && request.resource.data.trainerId == resource.data.trainerId && request.auth.uid == resource.data.trainerId;
      allow delete: if isSignedIn() && resource.data.trainerId == resource.data.trainerId && request.auth.uid == resource.data.trainerId;
    }

    /**
     * @description Controls access to course module information.
     * @path /courses/{courseId}/modules/{moduleId}
     * @allow (get, list) Public read access to course module information.
     * @allow (create) Only authenticated users can create courses modules, ensuring trainerId matches.
     * @allow (update, delete) Only the trainer (trainerId) can update or delete the course module.
     * @deny Write without authentication.
     * @principle Public read access with owner-only writes.
     */
    match /courses/{courseId}/modules/{moduleId} {
      function isSignedIn() {
        return request.auth != null;
      }

      allow get, list: if true;

      // TODO: Determine how to connect a course module to the trainerId from course document to create more secured writes
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Controls access to enrollment records.
     * @path /enrollments/{enrollmentId}
     * @allow (get, list) User with matching userId. (e.g., request.auth.uid == userId)
     * @allow (create) User creating their own enrollment (e.g., request.auth.uid == userId)
     * @allow (update, delete) Only the user can update or delete their enrollment.
     * @deny Any other user attempting to access or modify the enrollment.
     * @principle Enforces document ownership for writes.
     */
    match /enrollments/{enrollmentId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      function isSignedIn() {
        return request.auth != null;
      }
      allow get: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow list: if false;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow delete: if isSignedIn() && request.resource.data.userId == request.auth.uid;
    }

    /**
     * @description Controls access to job postings.
     * @path /jobPostings/{jobPostingId}
     * @allow (get, list) Public read access to job postings.
     * @allow (create) Only recruiters can create job postings, ensuring recruiterId matches.
     * @allow (update, delete) Only the recruiter (recruiterId) can update or delete the job posting.
     * @deny Write without authentication.
     * @principle Public read access with owner-only writes.
     */
    match /jobPostings/{jobPostingId} {
      function isSignedIn() {
        return request.auth != null;
      }

      allow get, list: if true;

      allow create: if isSignedIn() && request.resource.data.recruiterId == request.auth.uid;
      allow update: if isSignedIn() && request.resource.data.recruiterId == resource.data.recruiterId && request.auth.uid == resource.data.recruiterId;
      allow delete: if isSignedIn() && resource.data.recruiterId == resource.data.recruiterId && request.auth.uid == resource.data.recruiterId;
    }

    /**
     * @description Controls access to job applications.
     * @path /applications/{applicationId}
     * @allow (get) Applicant or recruiter can access the application.
     * @allow (list) Applicant or recruiter can list the application.
     * @allow (create) Only the applicant can create an application.
     * @allow (update, delete) Only the applicant or recruiter can update or delete the application.
     * @deny Other users attempting to access or modify the application.
     * @principle Shared access for job applications between applicant and recruiter.
     */
    match /applications/{applicationId} {
      function isApplicant(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      function isRecruiter(jobPostingId) {
        return get(/databases/$(database)/documents/jobPostings/$(jobPostingId)).data.recruiterId == request.auth.uid;
      }
      function isSignedIn() {
        return request.auth != null;
      }
      allow get: if isSignedIn() && (resource.data.userId == request.auth.uid || isRecruiter(resource.data.jobPostingId));
      allow list: if false;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isSignedIn() && (resource.data.userId == request.auth.uid || isRecruiter(resource.data.jobPostingId));
      allow delete: if isSignedIn() && (resource.data.userId == request.auth.uid || isRecruiter(resource.data.jobPostingId));
    }
  }
}